              ____   _              _____                    _ 
             |  _ \ / \            |_   _|__ _ __ ___   __ _/ |
             | |_) / _ \    _____    | |/ _ \ '_ ` _ \ / _` | |
             |  __/ ___ \  |_____|   | |  __/ | | | | | (_| | |
             |_| /_/   \_\           |_|\___|_| |_| |_|\__,_|_|

    Fiecare problemă moștenește interfața Problem, și deci are același format:
citește datele problemei dintr-un fișier dat ca parametru cu funcția Read(), calcu-
lează rezultatul cu funcția Solve() și scrie rezultatul într-un fișier dat ca parametru
cu funcția Write(). Aceste funcții pot fi apelate de oricâte ori pentru o instanță de
problemă, pentru recitirea datelor, scrierea într-un alt fișier sau recalcularea rezul-
tatelor.
  ___         _   _ 
 | __| _ __ _| |_(_)
 | _| '_/ _` |  _| |
 |_||_| \__,_|\__|_|

    Pentru ca fiecare frate să aibă mai multe obiecte preferate decât fratele său, iar
dacă acest lucru nu este posibil, diferența finală să fie cât mai mică, fiecare frate va
dori să aleagă concursul cu cele mai multe premii totale (suma dintre benzi și jocuri),
astfel încât să primească cât mai multe obiecte preferate și totodată să îl oprească pe
fratele său din a lua cât mai multe obiecte. În cazul în care există mai multe concur-
suri cu aceeași sumă, fiecare frate va dori să aleagă concursul care îi aduce cele mai
multe obiecte preferate.
    Pentru a obține această împărțire cât mai eficient, am definit operatorul < pentru
structura Contest (care conține 4 câmpuri - games, comics, sum - pentru a nu avea nevoie
să calculăm suma de fiecare dată - și chosen, care arată dacă acel concurs a fost deja
ales sau nu). Acest operator face ca std::sort să ordoneze vectorul de concursuri des-
crescător în funcție de sumă, iar concursurile cu aceeași sumă vor fi sortate descrescă-
tor în funcție de numărul de jocuri.
    Pentu a găsi, pe rând, fiecare concurs ales de fiecare frate, folosesc doi itera-
tori, start și end, care indică către primul, respectiv ultimul element din grupările
de concursuri care au aceeași sumă. Fie () => concursul nu a fost ales încă, [] -> con-
cursul a fost ales de Jon și {} => concursul a fost ales de Sam în exemplul următor:

            ... [19 10] (18 10) (16 12) (15 13) (10 18) (8 20) (12 10) ...
                           ↑                              ↑
                         start                           end

    "start" va indica către concursul pe care ar prefera Jon să îl aleagă (cu cele mai
multe jocuri), iar "end" va indica către concursul pe care ar prefera Sam să îl aleagă
(cu cele mai multe benzi). Presupunând că Jon a ales deja concursul (19 10), este rândul
lui Sam să aleagă. El va alege concursul indicat de end, iar end se va deplasa la stânga:

            ... [19 10] (18 10) (16 12) (15 13) (10 18) {8 20} (12 10) ...
                           ↑                       ↑
                         start                    end

    Acum este rândul lui Jon să aleagă: el va alege concursul indicat de start, iar
start se va deplasa la dreapta:

            ... [19 10] [18 10] (16 12) (15 13) (10 18) {8 20} (12 10) ...
                                   ↑               ↑
                                 start            end

    Din nou vine rândul lui Sam, care va alege concursul indicat de end:

            ... [19 10] [18 10] (16 12) (15 13) {10 18} {8 20} (12 10) ...
                                   ↑       ↑
                                 start    end

    Jon, la rândul lui, va alege iar concursul indicat de start, iar start va ajunge să
indice același concurs ca și end:

            ... [19 10] [18 10] [16 12] (15 13) {10 18} {8 20} (12 10) ...
                                           ↑
                                          end
                                         start

    Sam alege concursul indicat de end, iar acum, ambii iteratori indicând spre același
concurs și ultimul concurs din grupare fiind ales, ambii iteratori se vor deplasa către
următoarea grupare de concursuri cu aceeași sumă (chiar dacă este formată dintr-un sin-
gur concurs), și același algoritm va fi aplicat.

            ... [19 10] [18 10] [16 12] {15 13} {10 18} {8 20} (12 10) ...
                                                                  ↑
                                                                start
                                                                 end

    Complexitatea programului (worst-case) este după cum urmează:

→ Citire și salvare date: O(N)  │
→ Sortare vector: O(N * log(N)) │=> Total: O(N^2)
→ Algoritm de rezolvare: O(N^2) │
→ Scriere date: O(1)            │

  ___ _           _  __ _                 
 | _ \ |__ _ _ _ (_)/ _(_)__ __ _ _ _ ___ 
 |  _/ / _` | ' \| |  _| / _/ _` | '_/ -_)
 |_| |_\__,_|_||_|_|_| |_\__\__,_|_| \___|

    Pentru această problemă, am folosit un algoritm similar cu [weighted job scheduling]
(https://www.youtube.com/watch?v=cr6Ip0J9izc). Pentru eficientizare, am folosit un sin-
gur vector de "concursuri" care conține toate informațiile relevante:
- indicii primei și ultimei probe din cadrul concursului
- pierderea asociată concursului
- pierderea totală minimă de la primul concurs până la acesta
- numărul de concursuri asociat pierderii totale minime
    
    Am început prin a afla toate concursurile care pot fi obținute din probele și dura-
tele date și a le adăuga în vector, de la ultima probă spre prima, astfel încât concur-
surile să fie deja sortate descrescător în funcție de ultima probă, în vector.

    Conform algoritmului pentru weighted job scheduling, parcurg vectorul crescător
după ora de sfârșit (ultima probă, în cazul meu), deci de la sfârșit spre început. Pen-
tru fiecare concurs, verific concursurile (aflate după poziția lui în vector) care au
ora de sfârșit egală cu ora de început a concursului curent - 1. Salvez în vector valoa-
rea optimă asociată fiecărui concurs, iar rezultatul se va afla pe poziția 0, deoarece
am parcurs vectorul de la sfârșit către început.

    Complexitatea programului (worst-case) este după cum urmează:

→ Citire și salvare date: O(P)               │
→ Aflare concursuri posibile: O(P^2)         │=> Total: O(P^4)
→ Algoritm de rezolvare: O((P^2)^2) = O(P^4) │
→ Scriere date: O(1)                         │

    O altă abordare ar putea folosi căutare binară pentru o complexitate mai bună la
worst-case - O(P^2 * log(P^2)) -, dar în cazul meu nu este neapărat necesară deoarece
worst-case (situația în care durata unui concurs este mare, și toate probele pot
fi combinate unele cu altele pentru a forma concursuri diferite) are o șansă foarte
mică de a se întâmpla.